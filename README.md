# 4ChannelBAT16TRIACControl
An integrated IoT (Internet of Things) solution for controlling 4-Channel BAT16 TRIAC Board. This project is part of [ProgrammableIoTEnvironmentChamber](https://github.com/JiaweiHe98/ProgrammableIoTEnvironmentChamber).

## Overview

### Web Dashboard
<img src="./img/UI.png">
The solution is capable to control four dimmer channels simultaneously.

### Node-Red Flow
<img src="./img/Flow1.PNG">
The design is able to control the power output for each channel independently.

### 3D Printed Control Box
<img src="./img/3dBox v2.png">
The box can be compatible with fans range from 40mm to 70mm. It prevents electric shock caused by human contact and effectively dissipate the heat generated by the controller. For each of the base piece and the cover piece, a perfectly plain surface is designed to make the 3D printing process easier.

## Prepare for Developing
This section will guide you through the software and tools required for building this project.

### Visual Studio Code
Visual Studio Code, also known as VSCode, is a popular and powerful text editor for developers. A good text editor is crucial for speeding up the coding process and debugging process.

#### Install Visual Studio Code
We recommend to use the official website for downloading the packages.
Please go to [https://code.visualstudio.com/](https://code.visualstudio.com/) and follow the instruction on the web page.

#### Recommended Extensions
We recommend you to install the listed extensions for boosting your coding experience with VSCode
* Arduino
* C/C++
* Python
* vscode-icons

### Arduino IDE
Arduino IDE is a open-source integrated development environment designated for all Arduino boards. We will use this software to compile our code and burn it to our Arduino. It also has a serial monitor which allows us to interact with Arduino through serial communication.

#### Install Arduino IDE
We also recommend to use the official website for downloading the packages if you are on a Windows or MacOS machine.
Simply go to [https://www.arduino.cc/en/software](https://www.arduino.cc/en/software) and find out your version.
If you want to use a Raspberry Pi or a Linux machine to program the Arduino, you can simply update your software list by ```sudo apt-get update``` and install Arduino IDE by ```sudo apt-get install arduino``` in your console.

### Python
Python is a widely used program language and both python2 and python3 interpreters are pre installed into Raspberry Pi OS and MacOS.

#### Install Python3 for Windows
Go to [https://www.python.org/downloads/](https://www.python.org/downloads/) and choose the version you prefer. Don't forget to add PATH for python interpreter.

#### Install pyserial package
pyserial can be installed through command line with pip. Type ```pip install pyserial``` to add pyserial library.

### Node-Red
Node-Red is a visual programming tool based on Node.js. It allows you to edit working flows inside a web browser through a wide range of nodes and deploy your flow by simply click deploy button on the right top corner.

#### Install Node-Red
If you are using Raspberry Pi and you chose "Raspberry Pi OS with desktop and recommended software", Node-red is already installed into your Raspberry Pi. Simply click the start button on the top-left and go to programming tab. Then, you will able to find Node-Red.

If you are using a Windows machine, you first need to install Node.js and nmp. Go to [https://nodejs.org/](https://nodejs.org/) and download for Windows. Run the MSI file as administrator. Accept the default settings while installing. When finishing the installation, type ```node --version; npm --version``` in Powershell or ```node --version && npm --version``` in cmd to make sure that your installation is completed.

You should see something similar to this:
```
v14.15.3
6.14.9
```

Then, install Node-Red through ```npm install -g --unsafe-perm node-red``` and add ```node-red``` to your system path.

If you are using Linux, you can install Node-Red with npm, docker, or snap. You can follow the [Documentation](https://nodered.org/docs/getting-started/local) on Node-Red official website.

## Start Developing

### Phase Angle Control
Phase Angle Control is also known as "Phase-fired control (PFC)". Its principle is to modulate a thyristor or a TRIAC to control the amount of voltage, current or power flow into the controlled systems. 

#### Rectified voltage curve through Phase Angle Control
<img src="./img/phaseAngleControl.jpg">
This project uses a BAT16 TRIAC as the device for modulate the voltage. The TRIAC will be turned on when the pulse arrive and stays on until the voltage is flipped.

### Detect Zero-Crossing points
The Zero-Crossing Points are the exact time that the AC voltage reaches zero. We first need to use a full bridge rectifier to convert AC into DC. Then we will use a optocoupler to drop the voltage from 120V or 220V to around 5V, which allows us to use an Arduino to process the signal through digital input.

#### Hardware interrupt for Arduino
The kind of interrupt we are going to use is also known as external interrupts. However, not all of the pins on the Arduino support external interrupts. For Arduino UNO, only PIN2 and PIN3 and be used as external interrupt. You can check out [attachInterrupt() - Arduino Reference](https://www.arduino.cc/reference/en/language/functions/external-interrupts/attachinterrupt/) for more information.

#### Code for external interrupt
Syntax ```attachInterrupt(digitalPinToInterrupt(pin), ISR, mode)```

| Mode | Description |
| ------ | --------- |
| LOW | to trigger the interrupt when the pin is low |
| CHANGE | to trigger the interrupt when the pin state flips |
| RISING | to trigger the interrupt when state goes from low to high |
| FALLING | to trigger the interrupt when state goes from high to low |
| HIGH | to trigger the interrupt when the pin is high (only support Due, Zero, and MKR1000)
Code for this project:

```C
// Define the pin number as a variable will make the developing process easier and less likely to make mistakes
int zeroCrossing = 2; 

void setup() {
  // Initialize external interrupt
  attachInterrupt(digitalPinToInterrupt(zeroCrossing), sequenceStart, FALLING);
}
```

#### Firing pulse
BAT16 needs 500ns of pulse to be switched on. Firing the pulse can be defined as a function and we need to assign output pins.
```C
// Channel number to pin number
int ch1 = 8;
int ch2 = 9;
int ch3 = 10;
int ch4 = 11;

void setup() {
  // Initialize output pin
  pinMode(ch1, OUTPUT);
  pinMode(ch2, OUTPUT);
  pinMode(ch3, OUTPUT);
  pinMode(ch4, OUTPUT);
}

void loop() {
  //Don't need anything here for control the states of the pins

}
```
Firing function
```C
void firing(int chNum, bool state) {
  if (state) {
    digitalWrite(chNum, HIGH);
  } else {
    digitalWrite(chNum, LOW);
  }
}
```
You may notice that we did not use a delay function inside the firing the function. This is because that we need to control four channels in the same time. We cannot let the firing process block our code.

### Serial Communication
Serial communication allow us to send our settings to the Arduino and also let the Raspberry Pi to monitoring the working status of the Arduino.

#### Setup Serial Communication
On Raspberry Pi:
```Python
import serial

# The first argument specify the serial port of the device
# Usually 'COMx' for windows, 'dev/ttyUSBx' for Raspberry Pi
arduinoData = serial.Serial('COM1', 115200)
```

On Arduino:
```C
void setup() {
  // opens serial port, sets data rate to 115200 bps
  Serial.begin(115200);  
}
```

#### Transmitting Data
From Raspberry Pi to Arduino
```Python
arduinoData.write(str(power_set).encode())
```
From Arduino to Raspberry Pi
```C
void sendPower() {
  Serial.print("[");
  for (int i = 0; i < 4; i++) {
    Serial.print(power[i]);
    if (i < 3) {
      Serial.print(",");
    }
  }
  Serial.println("]");
}
```
We only need to exchange the power levels for four channels so that we can arrange the power level into a Python list or an array. In python, we can use ```str()``` function to convert a list to a string. In arduino, we can define a small function to do the same job.

#### Receiving Data
On Raspberry Pi:
```Python
dataFromArduino = arduinoData.readline().decode('ASCII')[:-2]
power_read = eval(dataFromArduino)
```
Since we already arrange the data in the format of a Python list, we can use ```eval``` function to evaluate the string into a Python list. There will be a ```\n``` at the end of the data from Arduino. So, we can skip the last two letters.

On Arduino:
```C
void receivePower() {
  for (int i = 0; i < 4; i++) {
    power[i] = Serial.parseInt();
  }
  bufferFlush();
  isChanged = true;
  sendPower();
}
```
On Arduino we can use ```parseInt()``` function to get the settings from data sent by Raspberry Pi. ```parseInt()``` will skip the brackets and Brackets in between automatically. A serial buffer is designed to Arduino, we don't need to worry that the Arduino will miss the information sent by Raspberry Pi.

## Node-Red Dashboard
<img src="./img/UI.png">
The gauges on the top show the current settings of each channel. The sliders below each gauge allow the users to assign new power level to each channel. We divided the power level into 1000 units. The line charts below the sliders help the users to monitor the history of the settings.

### Real-time interaction with Python scrip and Arduino
<img src="./img/PythonScript.png">
False at the end of each line indicates that there is no difference between the user defined settings and settings stored on Arduino

## Inter-process communication
We use a file to handle inter-process communication. The light intensity settings can be easily read from a file or write to a file with plain text. Therefore, we use a .txt file to store our settings and also to be our API between the Python script and Node-Red. The .txt file only contains 4 lines of integers.

```
100
200
1000
0
```

## Full Code:

### Arduino code

```C
//Main Timer
unsigned long startTime = micros();

// Channel number to pin number
int ch1 = 8;
int ch2 = 9;
int ch3 = 10;
int ch4 = 11;

// Zero-crossing point detection
int zeroCrossing = 2;

// Power output initialization
int power[4] = {0, 0, 0, 0};
int powerMax = 1000;

//Flag
bool isChanged = false;

// Firing queue initialization. 8333 to 0
int timings[8] = {-1, -1, -1, -1, -1, -1, -1, -1};
int channelNum[8] = {ch1, ch1, ch2, ch2, ch3, ch3, ch4, ch4};
bool states[8] = {true, false, true, false, true, false, true, false};

//sand back
unsigned long sendBack = millis();

// Setup serial connection and define pins
void setup() {
  // opens serial port, sets data rate to 115200 bps
  Serial.begin(115200);    

  // Initialize input pin
  pinMode(zeroCrossing, INPUT);

  // Initialize output pin
  pinMode(ch1, OUTPUT);
  pinMode(ch2, OUTPUT);
  pinMode(ch3, OUTPUT);
  pinMode(ch4, OUTPUT);

  // Initialize hardware interrupt, start sequence
  attachInterrupt(digitalPinToInterrupt(zeroCrossing), sequenceStart, FALLING);

  // send initial power level
  sendPower();
}

//Call functions in order
void loop() {

  //Save power
  if (micros() - startTime > 10^7) {
    delay(1000);
  }
  
  //Receive settings
  if (Serial.available() > 0) {
    receivePower();
  }

  //Update settings
  if (isChanged) {
    makeQueue();
    isChanged = false;
  }

  //Send back power levels
  if ((millis() - sendBack) > 10000) {
    sendPower();
    sendBack = millis();
  }

  // for debugging
//  delay(1000);
//  sendPower();
//  sequenceStart();
}


//For receiving settings
void receivePower() {
  for (int i = 0; i < 4; i++) {
    power[i] = Serial.parseInt();
  }
  bufferFlush();
  isChanged = true;
  sendPower();
}

//Send back power levels
void sendPower() {
  Serial.print("[");
  for (int i = 0; i < 4; i++) {
    Serial.print(power[i]);
    if (i < 3) {
      Serial.print(",");
    }
  }
  Serial.println("]");

// For debuging
//  Serial.print("[");
//  for (int i = 0; i < 8; i++) {
//    Serial.print(timings[i]);
//    if (i < 7) {
//      Serial.print(",");
//    }
//  }
//  Serial.println("]");
//  
//  Serial.print("[");
//  for (int i = 0; i < 8; i++) {
//    Serial.print(channelNum[i]);
//    if (i < 7) {
//      Serial.print(",");
//    }
//  }
//  Serial.println("]");
//
//  Serial.print("[");
//  for (int i = 0; i < 8; i++) {
//    Serial.print(states[i]);
//    if (i < 7) {
//      Serial.print(",");
//    }
//  }
//  Serial.println("]");
}

//Flush the remaining garbage information in serial buffer
void bufferFlush() {
  while(Serial.available() > 0) {
    char t = Serial.read();
  }
}

//Sending pulse to the dimmer
void firing(int chNum, bool state) {
  if (state) {
    digitalWrite(chNum, HIGH);
  } else {
    digitalWrite(chNum, LOW);
  }
}

//Make a queue for pulling up and pulling down the voltage of control pins
void makeQueue() {

  //Temporary arrays 
  int timeOn[4];
  int timeOnPin[4] = {ch1, ch2, ch3, ch4};
  int timeOff[4];
  int timeOffPin[4] = {ch1, ch2, ch3, ch4};

  //Push settings into temporary arrays. If power level is 0, output -1 for skipping the pulse
  for (int i = 0; i < 4; i++) {
    if (power[i] == 0) {
      timeOn[i] = -1;
      timeOff[i] = -1;
    } else {
      timeOn[i] = map(power[i], 0, powerMax, 8333, 0);
      timeOff[i] = timeOn[i] + 500;
    }
  }

  //Temporary variables for sorting
  int index;
  int minNum;
  int temp;

  //Sort timings of pulling up
  for (int i = 0; i < 3; i++) {
    minNum = timeOn[i];
    index = i;
    for (int j = i + 1; j < 4; j++) {
      if (timeOn[j] < minNum) {
        minNum = timeOn[j];
        index = j;
      }
    }
    if (index != i) {
      temp = timeOn[i];
      timeOn[i] = timeOn[index];
      timeOn[index] = temp;

      temp = timeOnPin[i];
      timeOnPin[i] = timeOnPin[index];
      timeOnPin[index] = temp;
    }
  }

  //sort timings of pulling down
  for (int i = 0; i < 3; i++) {
    minNum = timeOff[i];
    index = i;
    for (int j = i + 1; j < 4; j++) {
      if (timeOff[j] < minNum) {
        minNum = timeOff[j];
        index = j;
      }
    }
    if (index != i) {
      temp = timeOff[i];
      timeOff[i] = timeOff[index];
      timeOff[index] = temp;

      temp = timeOffPin[i];
      timeOffPin[i] = timeOffPin[index];
      timeOffPin[index] = temp;
    }
  }

  //merge 4 array
  int onIndex = 0;
  int offIndex = 0;
  int queueIndex = 0;

  while (onIndex < 4 && offIndex < 4) {
    if (timeOn[onIndex] < timeOff[offIndex]) {
      timings[queueIndex] = timeOn[onIndex];
      channelNum[queueIndex] = timeOnPin[onIndex];
      states[queueIndex] = true;
      onIndex ++;
    } else {
      timings[queueIndex] = timeOff[offIndex];
      channelNum[queueIndex] = timeOffPin[offIndex];
      states[queueIndex] = false;
      offIndex ++;
    }
    queueIndex ++;
  }

  if (onIndex >= 4) {
    while (queueIndex < 8) {
      timings[queueIndex] = timeOff[offIndex];
      channelNum[queueIndex] = timeOffPin[offIndex];
      states[queueIndex] = false;
      offIndex ++;
      queueIndex ++;
    }
  } else {
    while (queueIndex < 8) {
      timings[queueIndex] = timeOn[onIndex];
      channelNum[queueIndex] = timeOnPin[onIndex];
      states[queueIndex] = true;
      onIndex ++;
      queueIndex ++;
    }
  }
  
}

//Set zero crossing time
void sequenceStart() {

  //get start time
  startTime = micros();

  //initialize current time
  unsigned long timeNow;

  //start sequence
  for (int i = 0; i < 8; i ++) {
    timeNow = micros();
    if ((timeNow - startTime) < timings[i]) {
      delayMicroseconds(timings[i] - (timeNow - startTime));
    }

    //skip 0 power level
    if (timings[i] != -1) {
      firing(channelNum[i], states[i]);

      // for debugging
//      Serial.print("channelNum:");
//      Serial.print(channelNum[i]);
//      Serial.print("states:");
//      Serial.print(states[i]);
//      Serial.print("time:");
//      Serial.println(micros() - startTime);
    }
  }
}

```

### Python script on windows or Raspberry Pi

```python
'''
This module is used to handle the communicaiton between the Raspberry Pi and arduino
Communication relies on serial connection.
A USB cable can be used for physically connecting the Arduino to Raspberry Pi
'''

# If not found, you need to install pyserial
import serial
import time

# The first argument specify the serial port of the device
# Usually 'COMx' for windows, 'dev/ttyUSBx' for Raspberry Pi
arduinoData = serial.Serial('COM6', 115200)

# Power level initialization, power primarily goes from 0 to 1000
power_set = [0, 0, 0, 0]

# Reading settings from a file
while True:

    # Flag
    isChanged = False

    # Read the light intensity from file
    with open("lightIntensity.txt", "r") as light_intensity:

        # Read the light intensity from lines
        light_levels = light_intensity.readlines()
        
        # Update light intensity for each channel in order
        for i in range(4):

            # Parse int from string
            try:
                light_level = int(light_levels[i])

                if power_set[i] != light_level:
                    power_set[i] = light_level
                    isChanged = True

            # Print out error signal
            except:
                print('input file error!')

            
    # Update setting
    if isChanged:
        arduinoData.write(str(power_set).encode())
        isChanged = False

    # Decode message send back from Arduino
    start = time.perf_counter()
    dataFromArduino = arduinoData.readline().decode('ASCII')[:-2]
    end = time.perf_counter()

    # Convert string to list
    power_read = eval(dataFromArduino)

    # Check the power level of the Arduino and update the settings if the settings are different
    if power_read != power_set:
        arduinoData.write(str(power_set).encode())

    # For debug
    print(power_read, ' ', str(power_set).encode(), ' ', end - start, power_read != power_set)

```